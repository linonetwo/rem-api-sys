use clang::*;

use crate::build_utils::{
    config::HandlerConfigs, handle_function_prototype::MethodFlavor, process_children, HandlerMap,
};

pub fn handle_api_record(
    entity: &Entity,
    handlers: &HandlerMap,
    configs: &mut HandlerConfigs,
    full_rust_struct_name: &str,
) -> Vec<String> {
    let mut lines: Vec<String> = Vec::new();
    let vtable_struct_name = format!("{full_rust_struct_name}VTable");
    let full_trait_name = format!("{full_rust_struct_name}Trait");

    lines.push(format!("\n/* Generated by handle_api */"));
    lines.extend(handle_api(
        entity,
        handlers,
        configs,
        &full_rust_struct_name,
    ));

    lines
}

pub fn handle_api(
    entity: &Entity,
    handlers: &HandlerMap,
    configs: &HandlerConfigs,
    full_rust_struct_name: &str,
) -> Vec<String> {
    let mut lines = Vec::new();
    lines.push(format!(r#"
impl {full_rust_struct_name} {{
"#));
    lines.extend(process_children(
        entity,
        handlers,
        &mut HandlerConfigs {
            method_flavor: MethodFlavor::ApiTrait,
            ..configs.clone()
        },
    ));
    lines.push(format!(
        r#"
    /// encapsulate the raw pointer within CThostFtdcTraderApi
    pub unsafe fn from_raw(api_ptr: *mut CThostFtdcTraderApi) -> Box<CThostFtdcTraderApi> {{
        // Ensure the pointer is not null
        if api_ptr.is_null() {{
            panic!("CThostFtdcTraderApi pointer is null");
        }}

        // Dereference the pointer to obtain CThostFtdcTraderApi and return it
        // This assumes that CThostFtdcTraderApi can be directly obtained from the pointer
        // Adjust based on your actual struct layout
        Box::from_raw(api_ptr)
    }}
}}
unsafe impl Send for {full_rust_struct_name} {{}}
"#
    ));
    lines
}
